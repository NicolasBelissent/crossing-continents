---
import Head from "@/components/Head.astro";
import Header from "@/components/Header.astro";
import Footer from "@/components/Footer.astro";

interface Props {
  title?: string;
  description?: string;
}

const { title, description } = Astro.props;
---

<!doctype html>
<html lang="en">
  <head>
    <Head title={title} description={description} />
  </head>
  <body class="text-black" style="background-color: #EBF52E; transition: background-color 0.2s, color 0.2s;">
    <!-- Winding road with solid and dotted lines -->
    <svg id="road-svg" style="position: absolute; top: 0; left: 0; width: 100%; pointer-events: none; z-index: 0;">
      <!-- Outer solid lines -->
      <path id="road-left" fill="none" stroke="rgba(0, 0, 0, 1)" stroke-width="3" stroke-linecap="round"/>
      <path id="road-right" fill="none" stroke="rgba(0, 0, 0, 1)" stroke-width="3" stroke-linecap="round"/>
      <!-- Center dotted line -->
      <path id="road-center" fill="none" stroke="rgba(0, 0, 0, 1)" stroke-width="3" stroke-dasharray="20,20" stroke-linecap="round"/>
    </svg>

    <main style="position: relative; z-index: 10;">
      <slot />
    </main>
    <Footer />

    <script>
      const ROAD_WIDTH = 10; // Pixels between center line and edge lines

      function createWindingRoad() {
        const svg = document.getElementById('road-svg');
        const centerPath = document.getElementById('road-center');
        const leftPath = document.getElementById('road-left');
        const rightPath = document.getElementById('road-right');

        // Get footer position to stop the road there
        const footer = document.querySelector('footer');
        const footerTop = footer ? footer.offsetTop : document.documentElement.scrollHeight;
        const windowWidth = window.innerWidth;

        svg.setAttribute('height', footerTop);

        // Create winding path with curves every 100px
        let pathData = `M ${windowWidth / 2} 0`;
        let currentX = windowWidth / 2;
        const step = 100;

        for (let y = step; y < footerTop; y += step) {
          const offset = (Math.random() * 80 + 40) * (Math.random() > 0.5 ? 1 : -1);
          const nextX = Math.max(windowWidth * 0.3, Math.min(windowWidth * 0.7, currentX + offset));
          const controlY = y - step / 2;
          pathData += ` Q ${currentX} ${controlY}, ${nextX} ${y}`;
          currentX = nextX;
        }

        // Set center dotted line
        centerPath.setAttribute('d', pathData);

        // Create parallel offset paths for the solid lines
        const tempPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        tempPath.setAttribute('d', pathData);
        const pathLength = tempPath.getTotalLength();

        let leftPathData = '';
        let rightPathData = '';

        for (let i = 0; i <= pathLength; i += 5) {
          const point = tempPath.getPointAtLength(i);
          const nextPoint = tempPath.getPointAtLength(Math.min(i + 1, pathLength));

          // Calculate perpendicular angle
          const dx = nextPoint.x - point.x;
          const dy = nextPoint.y - point.y;
          const angle = Math.atan2(dy, dx);
          const perpAngle = angle + Math.PI / 2;

          // Offset points
          const leftX = point.x + Math.cos(perpAngle) * ROAD_WIDTH;
          const leftY = point.y + Math.sin(perpAngle) * ROAD_WIDTH;
          const rightX = point.x - Math.cos(perpAngle) * ROAD_WIDTH;
          const rightY = point.y - Math.sin(perpAngle) * ROAD_WIDTH;

          if (i === 0) {
            leftPathData = `M ${leftX} ${leftY}`;
            rightPathData = `M ${rightX} ${rightY}`;
          } else {
            leftPathData += ` L ${leftX} ${leftY}`;
            rightPathData += ` L ${rightX} ${rightY}`;
          }
        }

        leftPath.setAttribute('d', leftPathData);
        rightPath.setAttribute('d', rightPathData);
      }

      function updateColorBasedOnRoad(event) {
        const centerPath = document.getElementById('road-center');
        const body = document.body;
        const html = document.documentElement;

        if (!centerPath) return;

        const cursorX = event.clientX;
        const cursorY = event.clientY + window.scrollY;

        // Find closest point on path to cursor Y position
        const pathLength = centerPath.getTotalLength();
        let closestPoint = null;
        let minDistance = Infinity;

        for (let i = 0; i <= pathLength; i += 10) {
          const point = centerPath.getPointAtLength(i);
          const distance = Math.abs(point.y - cursorY);
          if (distance < minDistance) {
            minDistance = distance;
            closestPoint = point;
          }
        }

        if (closestPoint) {
          const isLeftOfRoad = cursorX < closestPoint.x;

          if (isLeftOfRoad) {
            body.style.backgroundColor = '#EBF52E';
            body.style.color = '#000000';
            html.classList.remove('red-mode');
            html.classList.add('yellow-mode');
          } else {
            body.style.backgroundColor = '#e5302d';
            body.style.color = '#ffffff';
            html.classList.remove('yellow-mode');
            html.classList.add('red-mode');
          }
        }
      }

      function updateRoadHeight() {
        const svg = document.getElementById('road-svg');
        const footer = document.querySelector('footer');
        const footerTop = footer ? footer.offsetTop : document.documentElement.scrollHeight;
        if (svg.getAttribute('height') !== footerTop.toString()) {
          createWindingRoad();
        }
      }

      // Initialize
      createWindingRoad();

      // Add mousemove listener
      document.addEventListener('mousemove', updateColorBasedOnRoad);

      // Update on scroll and resize
      window.addEventListener('scroll', updateRoadHeight);
      window.addEventListener('resize', createWindingRoad);

      // Check periodically for dynamic content changes
      setInterval(updateRoadHeight, 1000);

      // Re-initialize on view transitions
      document.addEventListener('astro:after-swap', () => {
        createWindingRoad();
        document.addEventListener('mousemove', updateColorBasedOnRoad);
      });
    </script>
  </body>
</html>
